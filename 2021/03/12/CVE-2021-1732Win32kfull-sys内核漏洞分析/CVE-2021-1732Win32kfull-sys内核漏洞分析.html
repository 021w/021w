<hr>
<p>ctitle: CVE-2021-1732Win32kfull.sys内核漏洞分析<br>date: 2021-03-12 15:53:36<br>tags: 漏洞分析</p>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>CVE-2021-1732</code>是在<code>win32kfull.sys</code>中的可以实现内核提权的漏洞,漏洞发生在<code>Windows</code>图形驱动<code>win32kfull!xxxCreateWindowEx</code>中,由于该函数调用win32kfull!xxxClientAllocWindowClassExtraBytes后而导致的漏洞.</p>
<!--more-->

<pre><code>win32kfull!xxxCreateWindowEx--&gt;win32kfull!xxxClientAllocWindowClassExtraBytes--&gt;KeUserModeCallback--&gt;用户态KiUserCallbackDispatcher--&gt;通过PEB获得KernelCallbackTable(保存在user32.dll)</code></pre>
<p>KernelCallbackTable的位置保存在peb中,peb地址可以通过代码获取,对表中回调函数地址进行替换 hook任意内核到用户态的回调函数.</p>
<h1 id="漏洞影响"><a href="#漏洞影响" class="headerlink" title="漏洞影响"></a>漏洞影响</h1><p>Windows Server, version 20H2 (Server Core Installation)</p>
<p>Windows 10 Version 20H2 for ARM64-based Systems</p>
<p>Windows 10 Version 20H2 for 32-bit Systems</p>
<p>Windows 10 Version 20H2 for x64-based Systems</p>
<p>Windows Server, version 2004 (Server Core installation)</p>
<p>Windows 10 Version 2004 for x64-based Systems</p>
<p>Windows 10 Version 2004 for ARM64-based Systems</p>
<p>Windows 10 Version 2004 for 32-bit Systems</p>
<p>Windows Server, version 1909 (Server Core installation)</p>
<p>Windows 10 Version 1909 for ARM64-based Systems</p>
<p>Windows 10 Version 1909 for x64-based Systems</p>
<p>Windows 10 Version 1909 for 32-bit Systems</p>
<p>Windows Server 2019 (Server Core installation)</p>
<p>Windows Server 2019</p>
<p>Windows 10 Version 1809 for ARM64-based Systems</p>
<p>Windws 10 Version 1809 for x64-based Systems</p>
<p>Windows 10 Version 1809 for 32-bit Systems</p>
<p>Windows 10 Version 1803 for ARM64-based Systems</p>
<p>Windows 10 Version 1803 for x64-based Systems</p>
<p>Windows 10 Version 1803 for 32-bit Systems</p>
<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>漏洞出现在win32kfull!xxxCreateWindowEx,当通过该函数创建窗口时,会调用xxxClientAllocWindowClassExtraBytes分配扩展内存,保存在tagWND+0x28+0x128的位置.</p>
<p><img src="Snipaste_2021-03-15_15-10-09.png"></p>
<p>xxxClientAllocWindowClassExtraBytes函数则会调用KeUserModeCallback进行回调</p>
<p><img src="Snipaste_2021-03-15_15-17-50.png"></p>
<p>该函数的解释在<a href="https://www.anquanke.com/post/id/184233">这里</a></p>
<pre><code>KeUserModeCallback (
    IN ULONG ApiNumber,
    IN PVOID InputBuffer,
    IN ULONG InputLength,
    OUT PVOID *OutputBuffer,
    IN PULONG OutputLength
    )</code></pre>
<p>从文章中我们可以看出,第一个参数是<code>PEB-&gt;KernelCallbackTable</code>函数表的一个index 根据这个index可以获取对应的回调函数地址,回调完毕通过int 2b返回内核</p>
<p>关于<a href="https://modexp.wordpress.com/2019/05/25/windows-injection-finspy/">KernelCallbackTable</a> 从文中可以知道,该结构可以在PEB中找到,所以我们可以获取PEB结构的地址,从而得到KernelCallbackTable的地址,进而去替换表中函数的地址进行hook.</p>
<p>找到KernelCallbackTable的偏移</p>
<pre><code>3: kd&gt; dt nt!_peb ee4622a000
   +0x000 InheritedAddressSpace : 0 &#39;&#39;
   +0x001 ReadImageFileExecOptions : 0 &#39;&#39;
   +0x002 BeingDebugged    : 0 &#39;&#39;
   +0x003 BitField         : 0x84 &#39;&#39;
   +0x003 ImageUsesLargePages : 0y0
   +0x003 IsProtectedProcess : 0y0
   +0x003 IsImageDynamicallyRelocated : 0y1
   +0x003 SkipPatchingUser32Forwarders : 0y0
   +0x003 IsPackagedProcess : 0y0
   +0x003 IsAppContainer   : 0y0
   +0x003 IsProtectedProcessLight : 0y0
   +0x003 IsLongPathAwareProcess : 0y1
   +0x004 Padding0         : [4]  &quot;&quot;
   +0x008 Mutant           : 0xffffffff`ffffffff Void
   +0x010 ImageBaseAddress : 0x00007ff7`37300000 Void
   +0x018 Ldr              : 0x00007ffa`998653c0 _PEB_LDR_DATA
   +0x020 ProcessParameters : 0x00000269`8fe81bd0 _RTL_USER_PROCESS_PARAMETERS
   +0x028 SubSystemData    : 0x00007ffa`94c1e120 Void
   +0x030 ProcessHeap      : 0x00000269`8fe80000 Void
   +0x038 FastPebLock      : 0x00007ffa`99864fe0 _RTL_CRITICAL_SECTION
   +0x040 AtlThunkSListPtr : (null) 
   +0x048 IFEOKey          : (null) 
   +0x050 CrossProcessFlags : 0
   +0x050 ProcessInJob     : 0y0
   +0x050 ProcessInitializing : 0y0
   +0x050 ProcessUsingVEH  : 0y0
   +0x050 ProcessUsingVCH  : 0y0
   +0x050 ProcessUsingFTH  : 0y0
   +0x050 ProcessPreviouslyThrottled : 0y0
   +0x050 ProcessCurrentlyThrottled : 0y0
   +0x050 ProcessImagesHotPatched : 0y0
   +0x050 ReservedBits0    : 0y000000000000000000000000 (0)
   +0x054 Padding1         : [4]  &quot;&quot;
   +0x058 KernelCallbackTable : 0x00007ffa`97be7330 Void
   +0x058 UserSharedInfoPtr : 0x00007ffa`97be7330 Void</code></pre>
<p>找到USER32!_xxxClientAllocWindowClassExtraBytes相对于KernelCallbackTable的偏移为0x3d8</p>
<pre><code>3: kd&gt; dps 0x00007ffa`97be7330 L100
00007ffa`97be7330  00007ffa`97b65160 USER32!_fnCOPYDATA
00007ffa`97be7338  00007ffa`97bdec70 USER32!_fnCOPYGLOBALDATA
00007ffa`97be7340  00007ffa`97b828a0 USER32!_fnDWORD
00007ffa`97be7348  00007ffa`97b86350 USER32!_fnNCDESTROY
​```
​```
00007ffa`97be7700  00007ffa`97bdf910 USER32!_xxxClientCallDevCallbackSimple
00007ffa`97be7708  00007ffa`97b876b0 USER32!_xxxClientAllocWindowClassExtraBytes
00007ffa`97be7710  00007ffa`97b87f30 USER32!_xxxClientFreeWindowClassExtraBytes

3: kd&gt; ? 00007ffa`97be7708-00007ffa`97be7330
Evaluate expression: 984 = 00000000`000003d8</code></pre>
<p>KiUserCallbackDispatcher通过peb获取该表的地址,通过PEB获取回调后,通过函数NtCallbackReturn返回内核地址.</p>
<p>如何去BSOD？</p>
<p>由于调用xxxClientAllocWindowClassExtraBytes回到用户态扩展内存,我们可以进行调用NtUserConsoleControl传入当前的窗口句柄,将当前窗口内核结构,并将当前窗口内核结构的成员修改为offset以及flag,使得flag=0x800,然后在回调函数中调用NtCallbackReturn返回任意值,返回之前会覆写offset,但flag没有清除,在销毁窗口时,导致越界写入.</p>
<p>NtUserConsoleControl调用xxxConsoleControl</p>
<p><img src="Snipaste_2021-03-16_09-50-13.png"></p>
<p>xxxConsoleControl里设置offset的值 并设置flag=0x800 此时寻址方式为0ffset了</p>
<p><img src="Snipaste_2021-03-16_09-48-55.png"></p>
<p>然后hook回调调用NtCallbackReturn 再次设置offset的值 但未设置flag的值 使用到此内存时 从而导致出错</p>
<p><img src="Snipaste_2021-03-15_15-10-09.png"></p>
<p>在后续的销毁窗口xxxDestroyWindows调用xxxFreeWindow 进而调用RtlFreeHeap</p>
<p><img src="Snipaste_2021-03-18_10-29-55.png"></p>
<p>释放内核堆出现越界访问<img src="Snipaste_2021-03-16_14-12-58.png"></p>
<p><img src="Snipaste_2021-03-23_15-43-53.png"></p>
<p>小小的总结一下</p>
<pre><code>---&gt;首先在xxxCreateWindowEx函数中 通过xxxClientAllocWindowClassExtraBytes设置了((TagWnd+0x28)+0x128)
---&gt;回调到用户空间 此时通过KernelCallbackTable进行hook调用NtuserConsoleControl从而到达xxxConsoleControl设置((TagWnd+0x28)+0x128)以及((TagWnd+0x28)+0xEB)的flag
---&gt;再去hook调用NtCallbackReturn会回到设置((TagWnd+0x28)+0x128)的值 但并没有改变其flag的值
---&gt;函数来到xxxDestroyWindows调用xxxFreeWindow 该函数中调用的RtlFreeHeap传参有((TagWnd+0x28)+0x128) 从而后续出错</code></pre>
<h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>目前已经可以实现hook用户回调了,需要做的是获取内核地址以及任意读写</p>
<p>使用我们的老熟人HMValidateHandle来获得内核地址</p>
<p><img src="Snipaste_2021-03-18_11-35-32.png"></p>
<p>获取NtUserComsoleControl和NtCallbackReturn的地址</p>
<p><img src="Snipaste_2021-03-22_15-17-51.png"></p>
<p>接下来获取KernelCallbackTable表的地址来hook xxxClientAllocWindowClassExtraBytes,gs寄存器偏移0x60处为PEB,PEB偏移0x58处为KernelCallbackTable.</p>
<p><img src="Snipaste_2021-03-22_16-11-41.png"></p>
<p><img src="Snipaste_2021-03-18_15-57-03.png"></p>
<p>此时Hook的地址已经是自定义函数了</p>
<p><img src="Snipaste_2021-03-22_16-42-04.png"></p>
<p>然后bypass DEP,使用<a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect">VirtualProtect</a>函数绕过DEP保护,将第三个参数设置为0x40即可.</p>
<p><img src="Snipaste_2021-03-18_16-10-18.png"></p>
<p>这里获得漏洞窗口的cbWndExtra是random取模0xff+0x1234或1来生成 此时的值为0x1269</p>
<p><img src="Snipaste_2021-03-23_09-27-05.png"></p>
<p>然后创建两个窗口一个用于利用 一个用于触发漏洞</p>
<p><img src="Snipaste_2021-03-18_16-11-41.png"></p>
<p><img src="Snipaste_2021-03-22_17-18-12.png"></p>
<p>接下来从堆中分配指定的字节数构造相应的menu 从而实现任意读写</p>
<p><img src="Snipaste_2021-03-18_16-15-14.png"></p>
<p><img src="Snipaste_2021-03-22_17-43-42.png"></p>
<p>创建10个窗口去泄露用户态tagWND结构体</p>
<p><img src="Snipaste_2021-03-18_16-17-17.png"></p>
<p>循环创建窗口</p>
<p><img src="Snipaste_2021-03-22_17-55-42.png"></p>
<p>主要是使用<a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualquery">VirtualQuery函数</a>,该函数检索有关调用进程的虚拟地址空间中的页面范围的信息,获取内存信息,找到窗口内存最小的基址.</p>
<p><img src="Snipaste_2021-03-21_20-51-45.png"></p>
<p>经过多次循环 我们得到最小的baseaddress和regionsize</p>
<p><img src="Snipaste_2021-03-23_09-56-17.png"></p>
<p>再根据偏移,计算head的句柄值,获取窗口句柄.</p>
<p><img src="Snipaste_2021-03-21_21-05-11.png"></p>
<p><img src="Snipaste_2021-03-23_10-40-06.png"></p>
<p>看雪上kk师傅的方法是,创建多个窗口,然后用HMValodateHandle获取窗口内核tagWND映射的用户堆,然后销毁窗口,再重新创建窗口, 此时使用的是刚才释放的窗口对象的内存,通过占坑操作,查找内存获取新窗口句柄.</p>
<p>接下来将2-10的窗口释放,调用NtUserConsoleControl将第0个窗口对象的扩展内存寻址方式设置为offset方式.</p>
<p><img src="Snipaste_2021-03-21_21-26-26.png"></p>
<p><img src="Snipaste_2021-03-23_10-38-47.png"></p>
<p>调用win32u!NtUserConsoleControl 此时通过寄存器可以看到hWndMin的值</p>
<p><img src="Snipaste_2021-03-23_10-43-16.png"></p>
<p>然后创建窗口,再利用<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowlonga">SetWindowW</a>函数将窗口的cbWndExtra设置为0xFFFFFFFF,具备读写能力.</p>
<p><img src="Snipaste_2021-03-21_21-30-56.png"></p>
<p><img src="Snipaste_2021-03-23_11-00-30.png"></p>
<p>win32kfull!xxxSetWindowLong函数中指定了寻址方式</p>
<p><img src="Snipaste_2021-03-21_21-45-02.png"></p>
<p>实现内核任意读</p>
<p><img src="Snipaste_2021-03-21_21-33-26.png"></p>
<p>此时已经获得任意读地址</p>
<p><img src="Snipaste_2021-03-23_11-22-23.png"></p>
<p>在win32kfull!xxxSetWindowPtrA函数中看到熟悉的代码进行设置offset的值</p>
<p><img src="Snipaste_2021-03-21_22-36-38.png"></p>
<p>借助任意读配合<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getmenubarinfo">GetMenuBarInfo</a>读取tagMenuBarInfo</p>
<p><img src="Snipaste_2021-03-21_21-37-21.png"></p>
<p>获得内核基址</p>
<p><img src="Snipaste_2021-03-23_14-15-47.png"></p>
<p>获得EPROCESS地址</p>
<p><img src="Snipaste_2021-03-23_14-39-25.png"></p>
<p>EPROCESS的地址(发现了两处 不过用的是偏移0x220处的)</p>
<p><img src="Snipaste_2021-03-23_14-40-27.png"></p>
<p>再根据获取的EPROCESS获得当前进程Token值以及System Token值</p>
<p><img src="Snipaste_2021-03-21_21-39-16.png"></p>
<p><img src="Snipaste_2021-03-23_14-56-36.png"></p>
<p>接下来进行写入封装 使用hWndMin的越界读写能力来实现g_hWndMax的任意读写去写入Token值 越界读写调用SetWindowLongPtrA修改g_hWndMax的pExtraBytes写入</p>
<p><img src="Snipaste_2021-03-21_23-07-22.png"></p>
<p>未调用前的Token值</p>
<p><img src="Snipaste_2021-03-23_15-33-14.png"></p>
<p>调用完成覆写之后的Token值</p>
<p><img src="Snipaste_2021-03-23_15-34-21.png"></p>
<p>最后恢复现场 将刚才修改过的值恢复 防止出错蓝屏</p>
<p><img src="Snipaste_2021-03-22_09-50-19.png"></p>
<p>小小的总结</p>
<pre><code>--&gt;用HMValidateHandle获取地址
--&gt;使用回调功能到KernelCallbackTable hook
--&gt;bypass DEP
--&gt;创建两个窗口 一个用于触发 一个用于利用
--&gt;实现任意读写原语(获取tagWND有两种思路 已提到)
--&gt;获取system Token值进行替换
--&gt;恢复现场 防止蓝屏</code></pre>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>kk师傅的分析：<a href="https://bbs.pediy.com/thread-225296.htm">https://bbs.pediy.com/thread-225296.htm</a></p>
<p>Saturn35师傅分析：<a href="https://saturn35.com/2021/03/16/20210316-1/#more">https://saturn35.com/2021/03/16/20210316-1/#more</a></p>
<p>KaLendsi的EXP：<a href="https://github.com/KaLendsi/CVE-2021-1732-Exploit">https://github.com/KaLendsi/CVE-2021-1732-Exploit</a></p>
<p>安恒的分析：<a href="https://ti.dbappsecurity.com.cn/blog/index.php/2021/02/10/windows-kernel-zero-day-exploit-is-used-by-bitter-apt-in-targeted-attack-cn/">https://ti.dbappsecurity.com.cn/blog/index.php/2021/02/10/windows-kernel-zero-day-exploit-is-used-by-bitter-apt-in-targeted-attack-cn/</a></p>
<p>LPE vulnerabilities：<a href="http://cvr-data.blogspot.com/2016/11/lpe-vulnerabilities-exploitation-on.html">http://cvr-data.blogspot.com/2016/11/lpe-vulnerabilities-exploitation-on.html</a></p>
<p>KernelCallbackTable信息：<a href="http://www.netfairy.net/?post=239">http://www.netfairy.net/?post=239</a></p>
<p>​                                            <a href="https://www.anquanke.com/post/id/184233">https://www.anquanke.com/post/id/184233</a></p>
<p>​                                            <a href="https://bbs.pediy.com/thread-104918.htm">https://bbs.pediy.com/thread-104918.htm</a></p>
<p>一些函数信息：<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getmenubarinfo">https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getmenubarinfo</a></p>
<p>​                        <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowlongw">https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowlongw</a></p>
<p>​                        <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualquery">https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualquery</a></p>
