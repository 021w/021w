{"meta":{"title":"021w","subtitle":null,"description":null,"author":"021w","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"CVE-2011-0027整数溢出漏洞分析","slug":"CVE-2011-0027整数溢出漏洞分析","date":"2020-09-29T09:21:42.000Z","updated":"2020-09-29T09:44:12.924Z","comments":true,"path":"2020/09/29/CVE-2011-0027整数溢出漏洞分析/","link":"","permalink":"http://yoursite.com/2020/09/29/CVE-2011-0027%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","excerpt":"0X00： 漏洞描述CVE-2011-0027 Microsoft Data Access组件整数溢出漏洞是Pwn2Own 2010黑客大赛中被用来攻破IE8浏览器的漏洞","text":"0X00： 漏洞描述CVE-2011-0027 Microsoft Data Access组件整数溢出漏洞是Pwn2Own 2010黑客大赛中被用来攻破IE8浏览器的漏洞 0X01 分析环境目标系统：Windows 7 32位 调试器：WinDbg 反汇编器：IDA Pro 漏洞软件：IE 8 0X02 基本信息首先开启IE的堆页保护打开IE附加进程 然后打开POC文件","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"}]},{"title":"CVE-2012-1876堆漏洞分析","slug":"CVE-2012-1876堆漏洞分析","date":"2020-09-25T05:35:26.000Z","updated":"2020-09-29T09:44:18.808Z","comments":true,"path":"2020/09/25/CVE-2012-1876堆漏洞分析/","link":"","permalink":"http://yoursite.com/2020/09/25/CVE-2012-1876%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","excerpt":"0X00 漏洞描述该IE浏览器漏洞的成因在mshtml.dll这个模块的CTableLayout::CalculateMinMax函数里，程序在执行时会以HTML代码中的元素span属性作为循环控制次数向堆中写入数据。如果此span值设置不当，那么就会引发堆溢出问题。","text":"0X00 漏洞描述该IE浏览器漏洞的成因在mshtml.dll这个模块的CTableLayout::CalculateMinMax函数里，程序在执行时会以HTML代码中的元素span属性作为循环控制次数向堆中写入数据。如果此span值设置不当，那么就会引发堆溢出问题。 0X01 分析环境目标系统：Windows 7 32位 调试器：WinDbg 反汇编器：IDA Pro 漏洞软件：IE 8 0X02 基本信息首先打开ie堆的hpa选项然后打开windbg附加ie进程并打开poc文件发现ie断了下来 断在了71290a2f 这里得选择两个进程中的后一个kb查看回溯代码 发现edi的值来源于esi通过前面我们可以知道再上一层函数是MSHTML!CTableLayout::CalculateMinMax 我们得下断点查看esi的值从何而来 重新运行然后lm显示已加载的模块 输出包含模块状态和路径 使用sxe ld:mshtml命令让进程在加载mshtml模块时断下 然后通过下断点bp MSHTML!CTableLayout::CalculateMinMax 单步运行调试 看到mov ebx,dword ptr [ebp+8] ss:002b:08bdc704=3bcd8ea8 [ebp+8]是参数1 poi()是指定地址处指针大小的数据ln命令显示给定地址处的或者最近的符号 可见参数1引用的是CTableLayout对象，也就是标签中的对象。这里的ebx+54h指向的是table标签里的col元素的span值，在poc中只有一个span值1，所以这里赋值1用IDA分析后 跟进CImplAry_EnsureSizeWorker函数 发现函数主要用作分配堆内存 分配的大小为spannnum0x1c 虽然spannum的值为1 但分配的最小值为0x1c4=0x70 分配的内存地址保存在CtableLayout+0x9c CImplAry_EnsureSizeWorker函数接下来我们查看缓冲区vulheap的地址 下断点bp mshtml!CTableLayout::CalculateMinMax+0x187直接执行到函数 然后单步步过查看ebp+0x9c的值就是vulheap的地址 查看堆块信息可知分配了0x70大小的内存在CtableLayou+0x9c指向的地址删除其他断点 只保留mshtml!CTableLayout::CalculateMinMax断点 再两次按g会弹出activex的弹窗 然后查看ebx+0x9c的值 发现并没变 再次g之后查看发现值发生变化 此时spancmp的值已经是4了 大于spansum的1 不发生跳转分配漏洞内存了 接下来我们在mshtml!CTableCol::GetAAspan下断点 然后步过这个函数 步出函数后发现我们设置的span值1000分析后续代码 了解到复制的内容相当于width100得到的值 复制的内容为0x411000=0x1004 在AdjustForCol中 会以1000*0x1c位计数循环 向vulheap写入数据 最终造成heap溢出 在IDA中找到了AdjustForCol的反汇编代码 可知a2为复制的内容 a3即vulheap经过循环递增偏移后得到的值 最大偏移为1000*0x1c 已经超出vulheap的范围 #0X03 思路总结1.加载页面 CTableLayout::CalculateMinMax被首次调用 span的值为1 spansum=1 spancmp=0 2.spancmp&lt;spansum 调用EnsureSizeWorke函数分配0x1cspansum的内存 至少分配 0x1c4=0x70的内存 3.分配内存后 spancmp=spansum*4=4 此时不在分配内存 4.调用over_trigger CTableLayout::MinMax第二次被调用 但是spansum和spancmp未变 但是span被改为1000 在复制width1000的数据到分配缓冲区 会以span为循环计数器写vulheap堆块 但是10000x1c&gt;0x70的值 造成溢出 #0X04 漏洞利用首先给jscript.dll和JscollectGarbage下断点然后开始运行找vulheap的位置断下然后关闭日志记录对于vulheap的内容我和书上对不上 就不太理解了#0X05 经验总结这次复现经历 基本算是顺利 就是再exp的调试出了点问题 基本算是学了些windbg的使用 比上一次调试知道了断在某个模块sxe ld:某模块 还有导出日志的信息等 以后就可更好的使用这些","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"}]},{"title":"CVE-2013-0077堆漏洞分析","slug":"CVE-2013-0077堆漏洞分析","date":"2020-09-22T09:53:50.000Z","updated":"2020-09-28T15:00:14.878Z","comments":true,"path":"2020/09/22/CVE-2013-0077堆漏洞分析/","link":"","permalink":"http://yoursite.com/2020/09/22/CVE-2013-0077%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","excerpt":"0X00： 漏洞描述exploit-db 漏洞公布站点上发布了 QQplayer.exe 3.7.892 m2p quartz.dll Heap Pointer OverWrite PoC，后被人提交至乌云。这个漏洞与 QQplayer.exe 没有任何关系 CVE-2013-0077是系统的quartz.dll在解析.m2p文件头时没有限制数据的大小 导致复制的数据超出了申请的栈空间","text":"0X00： 漏洞描述exploit-db 漏洞公布站点上发布了 QQplayer.exe 3.7.892 m2p quartz.dll Heap Pointer OverWrite PoC，后被人提交至乌云。这个漏洞与 QQplayer.exe 没有任何关系 CVE-2013-0077是系统的quartz.dll在解析.m2p文件头时没有限制数据的大小 导致复制的数据超出了申请的栈空间 0X01： 分析环境目标系统：Windows XP SP3 调试器：WinDbg 反汇编器：IDA Pro 漏洞软件：qqplayer 0X02：基本信息首先开启堆页保护然后用WinDbg附加进程 并打开poc.m2p文件 发现断在了7d0707e0重新打开WinDbg 附加进程 下断点运行后断在了断点处 查看esi和edi中的内容发现ecx的值为0x30 edi的值为02860f64则循环复制的次数就是0x30然后先bd 0禁用第一个断点 运行查看esi的值为02861000我们得到当前堆块分配的大小为0x9c查看栈回溯发现断点函数来自7d0706cc然后用IDA分析 加载quartz.dll 找到7d0706cc 查看反汇编代码然后找到漏洞处查看memcpy的函数原型对应IDA中的函数可知 a2的值并未改变 是从函数中传过来的 是函数的第三个参数我们用x32dbg加载程序 在7d0706cc设置断点 并打开poc 发现栈中的第三个值为0xc3 即函数的第三个参数的值为0x3c 即a2的值为0xc3 由此得出 我们之前直到堆空间只有0x9c的大小 而这里调用的memcpy函数却复制了0xc3的值造成了溢出 0X03：漏洞修复我们查看win7下的quartz.dll 用bindiff分析两个函数的对比然后查看该dll文件的76038668函数 发现该系统下的第三个参数的值已经被改为140 从而限制无法溢出 0X04：经验总结这个漏洞比较简单 分析起来也比较容易 堆块分配溢出的问题 然后结合bindiff工具分析补丁 然后用IDA查看到了补丁的改变","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"}]},{"title":"CVE-2012-0003 Microsoft Windows Media Player winmm.dll MIDI文件堆溢出漏洞","slug":"CVE-2012-0003堆漏洞分析","date":"2020-09-13T06:59:31.000Z","updated":"2020-09-28T15:02:53.860Z","comments":true,"path":"2020/09/13/CVE-2012-0003堆漏洞分析/","link":"","permalink":"http://yoursite.com/2020/09/13/CVE-2012-0003%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","excerpt":"0X00 漏洞描述CVE-2012-0003是微软的多媒体库 winmm.dll 在处理 MIDI 文件时，由于对数据处理不当导致的堆溢出，攻击者可在网页中嵌入恶意构造的 MIDI 文件来远程执行任意代码。","text":"0X00 漏洞描述CVE-2012-0003是微软的多媒体库 winmm.dll 在处理 MIDI 文件时，由于对数据处理不当导致的堆溢出，攻击者可在网页中嵌入恶意构造的 MIDI 文件来远程执行任意代码。 0X01 分析环境目标系统：Windows XP SP3 调试器：OllyDebug 反汇编器：IDA Pro 漏洞软件：IExplore 6、Media Player Metasploit：漏洞复现、利用 0X02 基本信息我们首先开启IE的堆页然后打开ie 用Immunity Debugger附加进程 然后将poc文件拖进ie 发现断在了0x76B2D224查看EBP的地址 栈回溯发现该函数被调用于0x76B2D038该函数位于winmm.dll中 使用IDA分析该dll文件我们找到V23和V20赋值的点我们可以看到V20是由V1赋值而来的 而V1=wParam其中wParam就是漏洞函数midiOutPlayNextPolyEvent的传递参数 而V20崩溃的可能性较低 所以我们来看下V23的来源 下图可以看到V23主要受V21和V13的影响我们经过一系列分析发现V13经过了V11V9V2以及最后的V1得来然后V21也是由V13得来的我们现在给各个参数下条件断点，观察各个值的变化 下面是对应参数的代码地址 12345678910| 变量 | C代码 | 汇编指令 | 记录值 | 地址 || v1 | mov esi, [edi+3Ch] | [edi+3ch] | 76B2D050 || v2 | mov ecx, [esi] | esi | 76B2D06D || v9 | mov ecx, [ebx+eax] | [ebx+eax] | 76B2D0B5 || V11| and ecx, 0FFFFFFh | ecx | 76B2D0C3 || V13| mov [ebp+var_8], ecx | ecx | 76B2D0D1 || V20| lea edx, [eax+esi] | [eax+esi] | 76B2D248 || V21| and dl, 0F0h | dl | 76B2D1F3 || V24| add esi, eax | eax | 76B2D21E || 参数a1 | cmp dword ptr [edi+34h], 0 | [edi+34h] | 76B2D044 | 给上面的参数都下类似于这样的断点我们下的断点总共如下接下来重新运行程序 我们通过观察日志文件可以看出V1 V2没变 V9递增 V11 V13不变且相等 V21等于V11/V13的最低位 V11=V13=0x007DB29F 我们在样本文件中也可以找到对应的下来看一下midi的文件格式 根据文件格式分析得到触发漏洞的是0x9x或者0x8x的音轨事件 V11和V13是包含参数的音轨 V21是音轨事件的类型 访问异常的时候 V11=V13=007DB29F 我们选择V11触发异常的地址 将其设置为0x007DB29F时断下 重新运行然后程序会停在此处往下运行找到溢出点我们继续查看esi的值 即为IDA中V20的值 最后发现是由参数a1得来继续通过IDA的交叉引用功能查看函数被调用自fptc函数在该函数中发现调用用的参数来自V6 而V6=wParam查看gpEmuList的引用情况，看“up”方向，w-写操作的，最终找到76B2CDAA函数而76B2CDAA函数里面又调用了76B2B29D函数这个函数却是个堆空间分配函数由此可得 esi是向堆空间申请0x400字节的内容 我们就可以看到漏洞是如何产生的 申请0x400字节空间的内容 赋值给esi 然后在处理“打开音符”事件时 偏移空间的大小为0x419 可以看出申请的空间不够从而导致堆溢出产生漏洞 #0X03： 经验总结堆的漏洞明显比栈上升一个档次了 结合IDA很好的分析了传参 给参数下了条件断点查看函数的日志信息分析函数 条件记录断点除了断点的作用 还能记录断点处的函数表达式或者参数的值 IDA的交叉引用可以很好的查看函数的调用","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"}]},{"title":"CVE-2011-0104 Microsoft Excel TOOLBARDEF漏洞复现","slug":"CVE-2011-0104栈漏洞分析","date":"2020-09-10T08:36:17.000Z","updated":"2020-09-28T15:02:43.421Z","comments":true,"path":"2020/09/10/CVE-2011-0104栈漏洞分析/","link":"","permalink":"http://yoursite.com/2020/09/10/CVE-2011-0104%E6%A0%88%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","excerpt":"0X00： 漏洞描述CVE-2011-0104是Microsoft Excel在解析XLB文件中的TOOLBARDEF Record时存在栈溢出漏洞，导致可执行任意代码。","text":"0X00： 漏洞描述CVE-2011-0104是Microsoft Excel在解析XLB文件中的TOOLBARDEF Record时存在栈溢出漏洞，导致可执行任意代码。 0X01： 分析环境操作系统：Windows XP SP3 调试器：OllyDbg 反汇编器：IDA Pro 漏洞软件：EXCEL 2003 0X02：基本信息WinDbg分析首先打开EXCEL软件 然后用WinDbg附加进程然后使用EXCEL加载漏洞文件 发现断在了0x300e06f7 OD分析我们使用OD打开EXCEL 在0x300e06f7处下断点 F9加载一个正常的EXCEL表格 进行栈回溯 看一下是那个函数调用奔溃函数 并给这里下断点（即0x300e5ad） 然后重新加载兵使用EXCEL打开漏洞文件 我们发现断在了刚才的断点处 并发现分配了0x60的栈空间 单步执行到0x300e05b3 数据窗口跟随ESP的值并下内存断点 F9运行到这里后下断点单步运行之后发现栈空间被POC覆盖 IDA分析我们用IDA打开EXCEL软件 然后回到复制栈数据的0x300de834 我们可以在OD中发现该函数位于）0x300de7ec函数中 在IDA中分析该函数 可以发现溢出点 循环复制导致溢出F5查看伪代码 可以发现是使用了memcpy函数导致溢出可以再回到OD中查看崩溃前共复制了0x300个字节 而前面我们提到过只分配了0x60个字节 所以导致溢出#0X03： 漏洞修复我们先来查看一下memcpy的函数原型 123456函数原型void *memcpy(void *destin, void *source, unsigned n);参数destin-- 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。source-- 指向要复制的数据源，类型强制转换为 void* 指针。-- 要被复制的字节数。 所以是函数设置的长度出了问题导致溢出 我们修改即可#X04： 经验总结之前也接触过windbg 一路从逆向走过来的 就是用的不太多 这次算是初步接触 虽然还是基本用OD动态调试 然后结合IDA分析 依然感觉OD好用 利用OD+IDA分析 可以很好的增加效率","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"}]},{"title":"CVE-2010-2883 Adobe Reader TTF字体SING表栈溢出漏洞","slug":"CVE-2010-2883栈漏洞分析","date":"2020-08-01T08:26:14.000Z","updated":"2020-09-28T15:02:19.555Z","comments":true,"path":"2020/08/01/CVE-2010-2883栈漏洞分析/","link":"","permalink":"http://yoursite.com/2020/08/01/CVE-2010-2883%E6%A0%88%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","excerpt":"0X00： 漏洞描述CVE-2010-2883是Adobe Reader和Acrobat中的CoolType.dll库在解析字体文件SING表中的uniqueName项时存在的栈溢出漏洞， 用户受骗打开了特制的PDF文件就有可能导致执行任意代码。","text":"0X00： 漏洞描述CVE-2010-2883是Adobe Reader和Acrobat中的CoolType.dll库在解析字体文件SING表中的uniqueName项时存在的栈溢出漏洞， 用户受骗打开了特制的PDF文件就有可能导致执行任意代码。 0X01： 分析环境操作系统：Windows XP SP3 调试器：OllyDbg 反汇编器：IDA Pro 漏洞软件：Adobe Reader 0X02：基本信息漏洞存在于Adobe Reader 8.2.4到9.3.4之间的版本，在CoolType.dll库中处理字体文件SING（ Smart INdependent Glyplets）表中uniqueName项时存在栈溢出漏洞。 我们用IDA打开CoolType.dll，找到漏洞位置我们可以看到strcat对字符串长度并没有进行判断，可以产生栈溢出 接下来对PDF文件进行分析 用PdfStreamDumper打开样本文件 然后将下列字段保存下来为TTF文件接下来看看TableEntry结构的定义：则偏移0x11c处就是SING表的真实数据 接着再偏移0x10即可找到uniqueName域 即：首先用OD打开Adobe Reader软件 并给0x803DCA4处下断点（就是strcat函数处）接下来打开msf.pdf运行后就可以到达断点位置 栈分布如图：我们跳转到0x12E4D8处并设置内存断点 并运行 访问数据会停下来运行多次之后返回用户空间F8单步运行到程序可能结束的call函数 一直运行步入逐步运行就会看到下一步要跳转到0x4A80CB38（ROP链）最终跳转到ROP链位置继续执行到0x4A82A714我们查看数据窗口的内容程序继续执行 可以看出数据是Heap Spary继续ROP 依次调用CreateFileA、CreateFileMappingA、MapViewOfFile，在内存中开辟一块可读可写可执行的地址。再调用memcpy，将shellcode拷贝到新的内存空间中去。一直将程序运行到ESP是4A8063A5 EIP将跳转执行 0X03： 经验总结第一次复现漏洞 发现了实际漏洞跟pwn的一些差别 可能是栈的原因 在IDA和配合OD的情况下觉得还不是那么大 挺好看出来的 跟着书上一步步来 利用ROP执行shellcode实现任意代码执行 在ctfwiki上也学到一些 不过跟实际漏洞还是差别蛮大的 要是自己单独去发现这些还是满困难的 道祖且长 慢慢来","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"}]}],"categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"}]}